
// webpack 优化 
// 1.Tree-shaking 
/* 
   过滤无用的js和css代码 减少打包后的体积 生产模式下自动启用
*/
// 2.代码分割
/*
  默认情况下会将所有用到的模块都打包到一个文件中
  代码分割就是将模块打包到不同的文件中

  例如在本地开发时 : 如果我们将js代码都打包到同一个文件中,当我们修改某个内容,webpack会重新打包
                    会生成不同文件名的hash值,由于是不同的文件,所以浏览器需要重新下载整个文件
                    每次修改,每次都会下载
                    假如我们将不经常修改的代码打包到另一个文件中,例如第三方库,这时由于第三方库
                    生成的文件内容没有变 对应hash值也没有变 所以浏览器会走缓存
                    只需要下载hash值变化了的文件
                    这里涉及到浏览器缓存的一些知识
*/
// 3.异步加载也称懒加载
/*
   为什么需要异步加载?例如某个页面/user 当我们首次访问时,会把所有的js代码(所有的模块)都去下载下来
   首次页面了增加网络请求时间,这时后页面中并没有用到所有的模块,所以我们需要在我们用到这个模块的时候才去加载
   所以异步加载 借助于webpack代码分割 和异步导入的import函数
   当我们在某个地方用的时候采取加载这个模块 也就是采取发起网络请求
        import("jquery").then(jquery => {
        console.log(jquery);
        });
    // 当然 不可能每次切换都去加载这个模块 所以会有浏览器缓存
*/
// 4_prefetching
/*
  懒加载也会有一些缺陷 如果异步加载的这个模块较大 用户需要等待这个模块加载完成后才能使用
  prefetching  是在空闲的时候加载 将现有的使用到的模块先加载完成,然后再加载这个异步模块
  然后当我们用到这个模块的时候,会去加载缓存 明显加快了网络请求速度 
*/
// 5.长缓存优化
// hash contenthash chunkhash
/*
 为什么需要在文名后面加一段hash字符串
 有这样一个场景 当我们访问一个html页面 浏览器会去下载所有的资源 这时候状态码都是200
 当我们刷新一下的时候 会有部分文件是304和disk cache 说明走了协商缓存或者强制缓存

 假如没有用hash值 那么每次修改得到的都是同一个文件名
 如果我们在某个时候时刻修改了文件内容,并重新发布了服务器
 我们在刷新浏览器并不会得到新的内容,因为浏览器会走缓存,通过script发起的请求是同一个文件名
 如果我们使用hash值这时候,文件名不一样了,那么浏览器就不会走缓存了

 还有一个疑问 上述将的缓存应该只对强制缓存有效,因为强制缓存不会发起浏览器请求
 但是协商缓存还是会发起浏览器请求,去询问服务器是否使用缓存
 这时候 可以这样 如果文件有修改 那么返回新的内容 200
 如果没有修改 返回304状态码

*/

// 6 .IgnorePlugin 用于忽略第三方包指定目录，让指定目录不被打包进去
// 7.resolve用于配置导入模块的解析规则
// 8. externals 优化打包速度 第三方包不会变化,每次打包都不需要打包第三方库
// 9. 1.什么是dll动态链接库?
/*
dll动态链接库和externals功能其实是一样的,
都是用于防止重复打包不会发生变化的第三方模块,
都是用于提升webpack打包效率的
只不过externals不太符合前端的模块化思想,externals需要全局引入第三方库,通过scripr引入这个库
 所以就有了dll动态链接库
 */
// 10 HappyPack 
/*
默认情况下webpack打包项目是单线程的, 为了提升打包速度, 充分发挥多核 CPU 电脑的威力
我们可以通过HappyPack让webpack实现多线程打包
*/
// 11.webpack-bundle-analyzer
/*
webpack-bundle-analyzer是一个可视化的打包优化插件
webpack-bundle-analyzer会将打包的结果以图形化界面的方式展示给我们
从webpack-bundle-analyzer生成的图形化界面中我们可以很清楚的知道
模块之间的依赖关系
模块大小
模块有没有重复打包, 重复引用等
从而针对性的对我们的代码进行优化
*/